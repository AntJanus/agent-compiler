---
phase: 04-cli-polish
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - src/file-safety/safe-writer.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "safeWrite detects and preserves original file line endings when writing"
    - "safeWrite checks write permissions before attempting backup or write"
    - "Permission failures throw ActionableError with resolution steps"
  artifacts:
    - path: "src/file-safety/safe-writer.ts"
      provides: "Integrated permission checking and line ending preservation"
      contains: "detectLineEnding"
      contains_also: "checkWritePermission"
  key_links:
    - from: "src/file-safety/safe-writer.ts"
      to: "src/file-safety/line-endings.ts"
      via: "import and call detectLineEnding, normalizeLineEnding"
      pattern: "detectLineEnding\\(targetPath\\)"
    - from: "src/file-safety/safe-writer.ts"
      to: "src/file-safety/permissions.ts"
      via: "import and call checkWritePermission"
      pattern: "checkWritePermission\\(targetPath\\)"
    - from: "src/file-safety/safe-writer.ts"
      to: "src/cli/output/messages.ts"
      via: "import and throw ActionableError"
      pattern: "createPermissionError"
---

<objective>
Integrate orphaned line ending and permission checking utilities into the safe-writer flow.

Purpose: Phase 4 verification found two critical gaps - line ending utilities and permission checking utilities exist but are never called. This plan wires them into the actual write flow to fulfill XPLAT-03 (line ending preservation) and ERROR-01 (proactive permission checking) requirements.

Output: Updated safe-writer.ts that preserves original line endings and checks permissions before operations.
</objective>

<execution_context>
@/Users/antonin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/antonin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-cli-polish/04-VERIFICATION.md

# Source files to modify
@src/file-safety/safe-writer.ts

# Utilities to integrate (already implemented, just need wiring)
@src/file-safety/line-endings.ts
@src/file-safety/permissions.ts
@src/cli/output/messages.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate permission checking into safeWrite</name>
  <files>src/file-safety/safe-writer.ts</files>
  <action>
Add proactive permission checking at the start of safeWrite function:

1. Add imports at top of file:
   - Import `checkWritePermission` from `./permissions.js`
   - Import `ActionableError, createPermissionError` from `../cli/output/messages.js`

2. Add permission check BEFORE backup creation (after options parsing, before Step 1):
   ```typescript
   // Step 0: Check write permissions before any operations
   const permCheck = await checkWritePermission(targetPath);
   if (!permCheck.canWrite) {
     const error = createPermissionError(targetPath);
     // Add the specific reason from permission check to context
     error.context.details = permCheck.reason || 'Unknown permission issue';
     throw error;
   }
   ```

3. Also check backup directory permission if different from target directory:
   ```typescript
   // Check backup directory permissions too
   const backupDirCheck = await checkWritePermission(options.backupDir + '/test');
   if (!backupDirCheck.canWrite) {
     throw new ActionableError(
       'Cannot create backups',
       {
         directory: options.backupDir,
         reason: backupDirCheck.reason || 'No write permission'
       },
       [
         'Check backup directory permissions',
         'Ensure directory exists and is writable',
         `Try: mkdir -p "${options.backupDir}"`
       ]
     );
   }
   ```

This ensures permission errors are caught BEFORE any file operations begin, with actionable resolution steps.
  </action>
  <verify>
Run: `npm run build` - should compile without errors
Grep: `grep -n "checkWritePermission" src/file-safety/safe-writer.ts` - should show import and call
  </verify>
  <done>
safeWrite calls checkWritePermission before backup/write operations and throws ActionableError with resolution steps when permission is denied.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate line ending preservation into safeWrite</name>
  <files>src/file-safety/safe-writer.ts</files>
  <action>
Add line ending detection and normalization to preserve original file line endings:

1. Add imports at top of file (if not already added):
   - Import `detectLineEnding, normalizeLineEnding` from `./line-endings.js`

2. After permission check, before backup creation, detect original line ending:
   ```typescript
   // Step 0.5: Detect original line ending to preserve it
   const originalLineEnding = await detectLineEnding(targetPath);
   // detectLineEnding returns 'LF' for new files (ENOENT), which is correct default
   ```

3. Before calling atomicWrite, normalize content to match original line ending:
   ```typescript
   // Normalize content to match original line ending
   const normalizedContent = normalizeLineEnding(content, originalLineEnding);
   ```

4. Update both atomicWrite calls to use normalizedContent:
   - Line ~48: `await atomicWrite(targetPath, normalizedContent);`
   - Line ~76: Keep backup restore using backupContent directly (it has correct endings)

The flow becomes:
1. Check permissions (Task 1)
2. Detect line ending from existing file (or default LF for new)
3. Create backup
4. Normalize content to match detected ending
5. Atomic write normalized content
6. Validate

This ensures CRLF files stay CRLF and LF files stay LF.
  </action>
  <verify>
Run: `npm run build` - should compile without errors
Grep: `grep -n "detectLineEnding\|normalizeLineEnding" src/file-safety/safe-writer.ts` - should show import and calls
  </verify>
  <done>
safeWrite detects original line ending before write and normalizes content to match, preserving CRLF/LF as appropriate.
  </done>
</task>

</tasks>

<verification>
## Integration Verification

1. Build succeeds: `npm run build`

2. Check imports wired correctly:
   ```bash
   grep -n "import.*checkWritePermission" src/file-safety/safe-writer.ts
   grep -n "import.*detectLineEnding" src/file-safety/safe-writer.ts
   grep -n "import.*ActionableError" src/file-safety/safe-writer.ts
   ```

3. Check functions are called (not just imported):
   ```bash
   grep -n "checkWritePermission(" src/file-safety/safe-writer.ts
   grep -n "detectLineEnding(" src/file-safety/safe-writer.ts
   grep -n "normalizeLineEnding(" src/file-safety/safe-writer.ts
   ```

4. Check ActionableError is thrown for permission issues:
   ```bash
   grep -n "createPermissionError\|new ActionableError" src/file-safety/safe-writer.ts
   ```
</verification>

<success_criteria>
1. safeWrite imports and calls checkWritePermission before backup creation
2. safeWrite throws ActionableError (not generic Error) when permission denied
3. safeWrite imports and calls detectLineEnding to get original line ending
4. safeWrite calls normalizeLineEnding on content before atomicWrite
5. Build passes with no TypeScript errors
6. Grep confirms all 4 utility functions are both imported AND called
</success_criteria>

<output>
After completion, create `.planning/phases/04-cli-polish/04-05-SUMMARY.md`
</output>
