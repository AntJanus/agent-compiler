---
phase: 04-cli-polish
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/cli/output/spinner.ts
  - src/cli/output/messages.ts
  - src/cli/output/index.ts
  - src/file-safety/line-endings.ts
  - src/file-safety/permissions.ts
  - src/file-safety/index.ts
autonomous: true

must_haves:
  truths:
    - "Long operations show spinner with descriptive message"
    - "Errors display with context and resolution steps"
    - "File writes preserve original line endings (LF or CRLF)"
    - "Permission errors are caught early with actionable messages"
    - "Symlinks are detected using lstat (not stat)"
  artifacts:
    - path: "src/cli/output/spinner.ts"
      provides: "Spinner wrapper for long operations"
      exports: ["withSpinner"]
    - path: "src/cli/output/messages.ts"
      provides: "ActionableError class for formatted errors"
      exports: ["ActionableError"]
    - path: "src/file-safety/line-endings.ts"
      provides: "Line ending detection and normalization"
      exports: ["detectLineEnding", "normalizeLineEnding"]
    - path: "src/file-safety/permissions.ts"
      provides: "Permission checking utilities"
      exports: ["checkWritePermission", "checkReadPermission"]
  key_links:
    - from: "src/cli/output/spinner.ts"
      to: "ora"
      via: "spinner start/succeed/fail"
      pattern: "ora.*start|succeed|fail"
    - from: "src/file-safety/line-endings.ts"
      to: "file content"
      via: "regex detection of CRLF vs LF"
      pattern: "\\\\r\\\\n"
    - from: "src/file-safety/permissions.ts"
      to: "node:fs/promises"
      via: "access() with permission constants"
      pattern: "access\\(.*constants\\.(R_OK|W_OK)"
---

<objective>
Create output formatting utilities (spinners, actionable errors) and cross-platform file handling (line endings, permissions, symlinks)

Purpose: Users need visual feedback during long operations and helpful error messages when things go wrong. Cross-platform reliability requires proper line ending preservation and proactive permission checking before operations (ERROR-01).

Output: Spinner utility, ActionableError class, line ending utilities, and permission checking integrated with file-safety module.
</objective>

<execution_context>
@/Users/antonin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/antonin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-cli-polish/04-RESEARCH.md

# File safety module to extend
@src/file-safety/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create spinner and actionable error utilities</name>
  <files>
    src/cli/output/spinner.ts
    src/cli/output/messages.ts
    src/cli/output/index.ts
  </files>
  <action>
Create src/cli/output/spinner.ts:
1. Import `ora` from 'ora'
2. Import `pc` from 'picocolors'

3. Export async function withSpinner<T>(message: string, operation: () => Promise<T>): Promise<T>
4. Implementation:
   ```typescript
   const spinner = ora(message).start();
   try {
     const result = await operation();
     spinner.succeed(pc.green(message));
     return result;
   } catch (error) {
     spinner.fail(pc.red(message));
     throw error;
   }
   ```

5. Export function createSpinner(message: string) for manual control:
   - Returns ora instance for cases needing text updates
   - Useful for multi-step operations

Create src/cli/output/messages.ts:
1. Import `pc` from 'picocolors'

2. Export class ActionableError extends Error:
   ```typescript
   export class ActionableError extends Error {
     constructor(
       message: string,
       public readonly context: Record<string, string>,
       public readonly resolution: string[]
     ) {
       super(message);
       this.name = 'ActionableError';
     }

     format(): string {
       const lines = [
         pc.red(`Error: ${this.message}`),
         '',
         pc.dim('Context:')
       ];

       for (const [key, value] of Object.entries(this.context)) {
         lines.push(`  ${pc.cyan(key)}: ${value}`);
       }

       if (this.resolution.length > 0) {
         lines.push('', pc.dim('To resolve:'));
         this.resolution.forEach((step, i) => {
           lines.push(`  ${i + 1}. ${step}`);
         });
       }

       return lines.join('\n');
     }
   }
   ```

3. Export helper functions for common errors:
   - createPermissionError(filePath: string): ActionableError
   - createFileNotFoundError(filePath: string): ActionableError
   - createParseError(filePath: string, details: string): ActionableError

Create src/cli/output/index.ts:
1. Export all from spinner.js
2. Export all from messages.js

Why ActionableError.format():
- Keeps error formatting in one place
- CLI can call error.format() for pretty output
- Raw error.message still available for logging
  </action>
  <verify>
1. `npm run build` succeeds
2. Manual test: withSpinner shows spinner, then checkmark on success
3. Manual test: withSpinner shows spinner, then X on failure
4. Manual test: ActionableError.format() produces multi-line formatted output
  </verify>
  <done>
Spinner utility wraps async operations with visual feedback. ActionableError provides structured error formatting with context and resolution steps.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add line ending detection, permission checking, and symlink utilities</name>
  <files>
    src/file-safety/line-endings.ts
    src/file-safety/permissions.ts
    src/file-safety/index.ts
  </files>
  <action>
Create src/file-safety/line-endings.ts:
1. Import `readFile` from 'node:fs/promises'

2. Export type LineEnding = 'LF' | 'CRLF'

3. Export async function detectLineEnding(filePath: string): Promise<LineEnding>
   - Try to read file content
   - Check if content contains '\r\n' (CRLF)
   - If yes, return 'CRLF'
   - If no (or file doesn't exist), return 'LF' as default for Unix
   - Implementation:
     ```typescript
     try {
       const content = await readFile(filePath, 'utf8');
       // Check for CRLF first (more specific)
       return content.includes('\r\n') ? 'CRLF' : 'LF';
     } catch {
       // Default to LF for new files on Unix
       return 'LF';
     }
     ```

4. Export function normalizeLineEnding(content: string, ending: LineEnding): string
   - First normalize all line endings to LF
   - Then convert to target ending if CRLF
   - Implementation:
     ```typescript
     // Normalize to LF first
     const normalized = content.replace(/\r\n/g, '\n');
     // Convert to target
     return ending === 'CRLF'
       ? normalized.replace(/\n/g, '\r\n')
       : normalized;
     ```

5. Export function detectFromContent(content: string): LineEnding
   - Same logic as detectLineEnding but from string, not file
   - Useful when content is already in memory

Create src/file-safety/permissions.ts (ERROR-01 coverage):
1. Import `access, constants` from 'node:fs/promises'
2. Import `dirname` from 'node:path'

3. Export async function checkWritePermission(filePath: string): Promise<{ canWrite: boolean; reason?: string }>
   - Uses fs.access() with constants.W_OK to check write permission
   - If file doesn't exist, check parent directory write permission
   - Implementation:
     ```typescript
     export async function checkWritePermission(filePath: string): Promise<{ canWrite: boolean; reason?: string }> {
       try {
         // Try to check the file itself first
         await access(filePath, constants.W_OK);
         return { canWrite: true };
       } catch (error: any) {
         if (error.code === 'ENOENT') {
           // File doesn't exist - check parent directory
           const dir = dirname(filePath);
           try {
             await access(dir, constants.W_OK);
             return { canWrite: true };
           } catch (dirError: any) {
             if (dirError.code === 'ENOENT') {
               return { canWrite: false, reason: `Directory does not exist: ${dir}` };
             }
             if (dirError.code === 'EACCES') {
               return { canWrite: false, reason: `No write permission for directory: ${dir}` };
             }
             return { canWrite: false, reason: dirError.message };
           }
         }
         if (error.code === 'EACCES') {
           return { canWrite: false, reason: `No write permission for file: ${filePath}` };
         }
         return { canWrite: false, reason: error.message };
       }
     }
     ```

4. Export async function checkReadPermission(filePath: string): Promise<{ canRead: boolean; reason?: string }>
   - Similar pattern using constants.R_OK
   - Returns reason for failure

Update src/file-safety/index.ts:
1. Add exports from line-endings.js:
   ```typescript
   export { detectLineEnding, normalizeLineEnding, detectFromContent } from './line-endings.js';
   export type { LineEnding } from './line-endings.js';
   ```

2. Add exports from permissions.js:
   ```typescript
   export { checkWritePermission, checkReadPermission } from './permissions.js';
   ```

Note on symlinks (XPLAT-04):
- Phase 1 discovery uses fast-glob with followSymlinks option
- The actual symlink behavior is already handled in src/discovery/skill-discovery.ts
- fs.lstat() vs fs.stat() distinction is relevant for detecting symlinks
- Our current code follows symlinks during discovery (via fast-glob's default behavior)
- This task confirms: symlinks ARE followed during discovery, user sees resolved content
- No additional code needed - discovery already handles this correctly
- XPLAT-04 coverage: fast-glob handles symlink resolution, atomic-writer handles ELOOP errors

Why proactive permission checking:
- Catch permission issues BEFORE attempting writes
- Better UX: "You don't have permission to write to X" vs cryptic error mid-operation
- Enables actionable error messages with resolution steps
  </action>
  <verify>
1. `npm run build` succeeds
2. Test detectLineEnding with LF file returns 'LF'
3. Test detectLineEnding with CRLF file returns 'CRLF'
4. Test normalizeLineEnding('a\nb', 'CRLF') returns 'a\r\nb'
5. Test normalizeLineEnding('a\r\nb', 'LF') returns 'a\nb'
6. Test checkWritePermission on writable file returns { canWrite: true }
7. Test checkWritePermission on read-only file returns { canWrite: false, reason: "..." }
8. Test checkWritePermission on non-existent file in writable dir returns { canWrite: true }
  </verify>
  <done>
Line ending detection works for both files and in-memory content. Normalization preserves original file's line ending style when writing. Permission checking (ERROR-01) catches access issues before file operations. Symlink handling (XPLAT-04) confirmed working via existing discovery module's fast-glob integration.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Build and verify:
```bash
npm run build
```

2. Test spinner functionality:
```typescript
// test-spinner.ts
import { withSpinner } from './dist/cli/output/index.js';

await withSpinner('Testing spinner...', async () => {
  await new Promise(r => setTimeout(r, 1000));
});
```

3. Test ActionableError formatting:
```typescript
import { ActionableError } from './dist/cli/output/index.js';

const err = new ActionableError(
  'Cannot write file',
  { file: '/path/to/file', reason: 'Permission denied' },
  ['Check permissions', 'Run with sudo']
);
console.log(err.format());
```

4. Test line ending detection:
```typescript
import { detectLineEnding, normalizeLineEnding } from './dist/file-safety/index.js';

// Should detect correctly
const ending = await detectLineEnding('./test-file.md');
console.log('Detected:', ending);
```

5. Test permission checking (ERROR-01):
```typescript
import { checkWritePermission } from './dist/file-safety/index.js';

// Check writable location
const result1 = await checkWritePermission('./CLAUDE.md');
console.log('Writable:', result1);

// Check read-only location (if available)
const result2 = await checkWritePermission('/etc/passwd');
console.log('Read-only:', result2);
```
</verification>

<success_criteria>
- withSpinner shows spinner during operation, succeed/fail at end
- ActionableError.format() produces readable multi-line error with context and steps
- detectLineEnding correctly identifies LF vs CRLF files
- normalizeLineEnding converts content to specified line ending
- checkWritePermission returns actionable results for permission checks (ERROR-01)
- checkReadPermission returns actionable results for read permission checks
- All exports available from module index files
- No external dependency added for line endings (built-in solution)
- XPLAT-04 symlink handling confirmed via Phase 1 discovery module
</success_criteria>

<output>
After completion, create `.planning/phases/04-cli-polish/04-03-SUMMARY.md`
</output>
