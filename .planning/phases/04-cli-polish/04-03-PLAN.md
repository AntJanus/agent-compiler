---
phase: 04-cli-polish
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/cli/output/spinner.ts
  - src/cli/output/messages.ts
  - src/cli/output/index.ts
  - src/file-safety/line-endings.ts
  - src/file-safety/index.ts
autonomous: true

must_haves:
  truths:
    - "Long operations show spinner with descriptive message"
    - "Errors display with context and resolution steps"
    - "File writes preserve original line endings (LF or CRLF)"
    - "Symlinks are detected using lstat (not stat)"
  artifacts:
    - path: "src/cli/output/spinner.ts"
      provides: "Spinner wrapper for long operations"
      exports: ["withSpinner"]
    - path: "src/cli/output/messages.ts"
      provides: "ActionableError class for formatted errors"
      exports: ["ActionableError"]
    - path: "src/file-safety/line-endings.ts"
      provides: "Line ending detection and normalization"
      exports: ["detectLineEnding", "normalizeLineEnding"]
  key_links:
    - from: "src/cli/output/spinner.ts"
      to: "ora"
      via: "spinner start/succeed/fail"
      pattern: "ora.*start|succeed|fail"
    - from: "src/file-safety/line-endings.ts"
      to: "file content"
      via: "regex detection of CRLF vs LF"
      pattern: "\\\\r\\\\n"
---

<objective>
Create output formatting utilities (spinners, actionable errors) and cross-platform file handling (line endings, symlinks)

Purpose: Users need visual feedback during long operations and helpful error messages when things go wrong. Cross-platform reliability requires proper line ending preservation.

Output: Spinner utility, ActionableError class, and line ending utilities integrated with file-safety module.
</objective>

<execution_context>
@/Users/antonin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/antonin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-cli-polish/04-RESEARCH.md

# File safety module to extend
@src/file-safety/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create spinner and actionable error utilities</name>
  <files>
    src/cli/output/spinner.ts
    src/cli/output/messages.ts
    src/cli/output/index.ts
  </files>
  <action>
Create src/cli/output/spinner.ts:
1. Import `ora` from 'ora'
2. Import `pc` from 'picocolors'

3. Export async function withSpinner<T>(message: string, operation: () => Promise<T>): Promise<T>
4. Implementation:
   ```typescript
   const spinner = ora(message).start();
   try {
     const result = await operation();
     spinner.succeed(pc.green(message));
     return result;
   } catch (error) {
     spinner.fail(pc.red(message));
     throw error;
   }
   ```

5. Export function createSpinner(message: string) for manual control:
   - Returns ora instance for cases needing text updates
   - Useful for multi-step operations

Create src/cli/output/messages.ts:
1. Import `pc` from 'picocolors'

2. Export class ActionableError extends Error:
   ```typescript
   export class ActionableError extends Error {
     constructor(
       message: string,
       public readonly context: Record<string, string>,
       public readonly resolution: string[]
     ) {
       super(message);
       this.name = 'ActionableError';
     }

     format(): string {
       const lines = [
         pc.red(`Error: ${this.message}`),
         '',
         pc.dim('Context:')
       ];

       for (const [key, value] of Object.entries(this.context)) {
         lines.push(`  ${pc.cyan(key)}: ${value}`);
       }

       if (this.resolution.length > 0) {
         lines.push('', pc.dim('To resolve:'));
         this.resolution.forEach((step, i) => {
           lines.push(`  ${i + 1}. ${step}`);
         });
       }

       return lines.join('\n');
     }
   }
   ```

3. Export helper functions for common errors:
   - createPermissionError(filePath: string): ActionableError
   - createFileNotFoundError(filePath: string): ActionableError
   - createParseError(filePath: string, details: string): ActionableError

Create src/cli/output/index.ts:
1. Export all from spinner.js
2. Export all from messages.js

Why ActionableError.format():
- Keeps error formatting in one place
- CLI can call error.format() for pretty output
- Raw error.message still available for logging
  </action>
  <verify>
1. `npm run build` succeeds
2. Manual test: withSpinner shows spinner, then checkmark on success
3. Manual test: withSpinner shows spinner, then X on failure
4. Manual test: ActionableError.format() produces multi-line formatted output
  </verify>
  <done>
Spinner utility wraps async operations with visual feedback. ActionableError provides structured error formatting with context and resolution steps.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add line ending detection and symlink handling utilities</name>
  <files>
    src/file-safety/line-endings.ts
    src/file-safety/index.ts
  </files>
  <action>
Create src/file-safety/line-endings.ts:
1. Import `readFile` from 'node:fs/promises'

2. Export type LineEnding = 'LF' | 'CRLF'

3. Export async function detectLineEnding(filePath: string): Promise<LineEnding>
   - Try to read file content
   - Check if content contains '\r\n' (CRLF)
   - If yes, return 'CRLF'
   - If no (or file doesn't exist), return 'LF' as default for Unix
   - Implementation:
     ```typescript
     try {
       const content = await readFile(filePath, 'utf8');
       // Check for CRLF first (more specific)
       return content.includes('\r\n') ? 'CRLF' : 'LF';
     } catch {
       // Default to LF for new files on Unix
       return 'LF';
     }
     ```

4. Export function normalizeLineEnding(content: string, ending: LineEnding): string
   - First normalize all line endings to LF
   - Then convert to target ending if CRLF
   - Implementation:
     ```typescript
     // Normalize to LF first
     const normalized = content.replace(/\r\n/g, '\n');
     // Convert to target
     return ending === 'CRLF'
       ? normalized.replace(/\n/g, '\r\n')
       : normalized;
     ```

5. Export function detectFromContent(content: string): LineEnding
   - Same logic as detectLineEnding but from string, not file
   - Useful when content is already in memory

Update src/file-safety/index.ts:
1. Add exports from line-endings.js:
   ```typescript
   export { detectLineEnding, normalizeLineEnding, detectFromContent } from './line-endings.js';
   export type { LineEnding } from './line-endings.js';
   ```

Note on symlinks:
- The research says use fs.lstat() not fs.stat() for symlink detection
- This is already handled correctly in Phase 1 discovery (fast-glob followSymlinks option)
- No additional code needed here - discovery already follows symlinks per decision in 01-02

Why not use crlf package:
- Simple detection is just checking for '\r\n'
- Package adds dependency for trivial functionality
- Our implementation handles the 99% case correctly
  </action>
  <verify>
1. `npm run build` succeeds
2. Test detectLineEnding with LF file returns 'LF'
3. Test detectLineEnding with CRLF file returns 'CRLF'
4. Test normalizeLineEnding('a\nb', 'CRLF') returns 'a\r\nb'
5. Test normalizeLineEnding('a\r\nb', 'LF') returns 'a\nb'
  </verify>
  <done>
Line ending detection works for both files and in-memory content. Normalization preserves original file's line ending style when writing. Symlink handling confirmed working via existing discovery module.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Build and verify:
```bash
npm run build
```

2. Test spinner functionality:
```typescript
// test-spinner.ts
import { withSpinner } from './dist/cli/output/index.js';

await withSpinner('Testing spinner...', async () => {
  await new Promise(r => setTimeout(r, 1000));
});
```

3. Test ActionableError formatting:
```typescript
import { ActionableError } from './dist/cli/output/index.js';

const err = new ActionableError(
  'Cannot write file',
  { file: '/path/to/file', reason: 'Permission denied' },
  ['Check permissions', 'Run with sudo']
);
console.log(err.format());
```

4. Test line ending detection:
```typescript
import { detectLineEnding, normalizeLineEnding } from './dist/file-safety/index.js';

// Should detect correctly
const ending = await detectLineEnding('./test-file.md');
console.log('Detected:', ending);
```
</verification>

<success_criteria>
- withSpinner shows spinner during operation, succeed/fail at end
- ActionableError.format() produces readable multi-line error with context and steps
- detectLineEnding correctly identifies LF vs CRLF files
- normalizeLineEnding converts content to specified line ending
- All exports available from module index files
- No external dependency added for line endings (built-in solution)
</success_criteria>

<output>
After completion, create `.planning/phases/04-cli-polish/04-03-SUMMARY.md`
</output>
