---
phase: 03-core-embedding
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - src/embedding/content-merger.ts
  - src/embedding/index.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Tool reads existing CLAUDE.md content before modifications"
    - "Tool removes previously embedded sections when re-running"
    - "Tool inserts new embedded sections at end of file after user content"
    - "Tool preserves all original user content outside embedded sections"
    - "Tool validates user content unchanged using hash comparison"
    - "Tool skips write when content is identical (idempotency)"
    - "Horizontal rule separator between user content and embedded sections"
  artifacts:
    - path: "src/embedding/content-merger.ts"
      provides: "Merge orchestrator with idempotency and validation"
      exports: ["mergeEmbeddedContent", "MergeOptions", "MergeResult"]
    - path: "src/embedding/index.ts"
      provides: "Unified embedding module exports"
      exports: ["mergeEmbeddedContent", "splitContent", "generateSkillsSection", "generateCommandsSection", "generateTemplate"]
  key_links:
    - from: "src/embedding/content-merger.ts"
      to: "src/embedding/section-extractor.ts"
      via: "splitContent import"
      pattern: "import.*splitContent.*from.*section-extractor"
    - from: "src/embedding/content-merger.ts"
      to: "src/embedding/section-generator.ts"
      via: "section generators import"
      pattern: "import.*generate.*Section.*from.*section-generator"
    - from: "src/embedding/content-merger.ts"
      to: "src/file-safety/safe-writer.ts"
      via: "safeWrite import"
      pattern: "import.*safeWrite.*from.*file-safety"
    - from: "src/embedding/content-merger.ts"
      to: "src/file-safety/hash-generator.ts"
      via: "generateContentHash import"
      pattern: "import.*generateContentHash.*from.*hash-generator"
---

<objective>
Implement the merge orchestrator that combines user content with embedded sections, handles idempotency through content hashing, and validates user content preservation.

Purpose: This is the main embedding API. It reads existing files, preserves user content, replaces embedded sections, and ensures safe writes with validation. Satisfies EMBED-01 through EMBED-06 and VALID-01 through VALID-04.

Output: content-merger.ts as the primary embedding API, index.ts exporting the complete embedding module.
</objective>

<execution_context>
@/Users/antonin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/antonin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-core-embedding/03-CONTEXT.md
@.planning/phases/03-core-embedding/03-RESEARCH.md

# Dependencies from this phase
@.planning/phases/03-core-embedding/03-01-PLAN.md
@.planning/phases/03-core-embedding/03-02-PLAN.md

# File safety infrastructure from Phase 2
@src/file-safety/safe-writer.ts
@src/file-safety/hash-generator.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement merge orchestrator with idempotency and validation</name>
  <files>src/embedding/content-merger.ts</files>
  <action>
Create `src/embedding/content-merger.ts` implementing the complete merge flow.

**Types:**
```typescript
export interface MergeOptions {
  /** Path to target file (CLAUDE.md or AGENTS.md) */
  targetPath: string;
  /** Parsed skills to embed */
  skills: ParsedSkill[];
  /** Parsed commands to embed */
  commands: ParsedCommand[];
  /** Directory for backups */
  backupDir: string;
}

export interface MergeResult {
  /** Whether operation succeeded */
  success: boolean;
  /** True if write skipped due to identical content */
  skipped: boolean;
  /** Path to backup if created */
  backupPath?: string;
  /** Whether file was newly created */
  created: boolean;
  /** User content hash for audit */
  userContentHash: string;
}
```

**Main function: mergeEmbeddedContent(options: MergeOptions): Promise<MergeResult>**

Implement the flow from RESEARCH.md Pattern 7:

1. **Read or create content:**
   - Try reading targetPath with fs/promises readFile
   - If ENOENT, generate template using generateTemplate (set created=true)
   - If other error, rethrow

2. **Split content:**
   - Call splitContent() to separate user content and find embedded sections
   - Store userContentHash for validation

3. **Generate new embedded sections:**
   - Call generateSkillsSection(skills)
   - Call generateCommandsSection(commands)

4. **Assemble merged content:**
   - Start with userContent.trim()
   - Add blank line if userContent is not empty
   - Add `---` separator (per user decision)
   - Add blank line
   - Add skills section if not empty
   - Add blank line between sections if both exist
   - Add commands section if not empty
   - Final trim

5. **Check idempotency:**
   - Read existing file content (if exists)
   - Normalize both contents: trim, replace \r\n with \n, collapse 3+ blank lines to 2
   - Generate hash of normalized existing vs normalized new
   - If hashes match, return { success: true, skipped: true, ... }

6. **Write with safeWrite:**
   - Call safeWrite(targetPath, mergedContent, { backupDir, validate: true })
   - Handle write result

7. **Validate user content preserved:**
   - Read written file
   - Call splitContent on written file
   - Compare userContentHash before and after
   - If mismatch: throw error with backup path for recovery
   - CRITICAL: This validation catches any bugs in our section detection

**Imports:**
```typescript
import { readFile } from 'fs/promises';
import { splitContent } from './section-extractor.js';
import { generateSkillsSection, generateCommandsSection } from './section-generator.js';
import { generateTemplate } from './template-generator.js';
import { safeWrite } from '../file-safety/safe-writer.js';
import { generateContentHash } from '../file-safety/hash-generator.js';
import type { ParsedSkill, ParsedCommand } from '../types/index.js';
```

**Content normalization helper:**
```typescript
function normalizeForComparison(content: string): string {
  return content
    .trim()
    .replace(/\r\n/g, '\n')
    .replace(/\n{3,}/g, '\n\n');
}
```

**Error handling:**
- File read errors (except ENOENT): rethrow with context
- safeWrite failures: rethrow (safeWrite handles backup)
- User content validation failure: throw with backup path and hash details
  </action>
  <verify>
`npm run build` succeeds.

Create integration test:
```typescript
import { mergeEmbeddedContent } from './src/embedding/content-merger.js';
import { readFile, writeFile, mkdir, rm } from 'fs/promises';
import { join } from 'path';

const testDir = '/tmp/embedding-test';
const targetPath = join(testDir, 'CLAUDE.md');
const backupDir = join(testDir, 'backups');

// Setup
await rm(testDir, { recursive: true, force: true });
await mkdir(backupDir, { recursive: true });

// Test 1: New file creation
const result1 = await mergeEmbeddedContent({
  targetPath,
  skills: [{
    path: '/test/skill',
    location: 'global',
    metadata: { name: 'Test Skill', description: 'Test' },
    content: 'Skill content here.',
    referencedFiles: []
  }],
  commands: [],
  backupDir
});
console.log('Test 1 - New file:', result1.created, result1.success);

// Test 2: Idempotency (same content)
const result2 = await mergeEmbeddedContent({
  targetPath,
  skills: [{
    path: '/test/skill',
    location: 'global',
    metadata: { name: 'Test Skill', description: 'Test' },
    content: 'Skill content here.',
    referencedFiles: []
  }],
  commands: [],
  backupDir
});
console.log('Test 2 - Idempotent:', result2.skipped);

// Test 3: User content preserved
await writeFile(targetPath, `# My Project

Custom user content that must be preserved.

---

## SKILLS

### Old Skill
Old content.
`);

const result3 = await mergeEmbeddedContent({
  targetPath,
  skills: [{
    path: '/test/skill',
    location: 'global',
    metadata: { name: 'New Skill', description: 'New' },
    content: 'New skill content.',
    referencedFiles: []
  }],
  commands: [],
  backupDir
});

const content = await readFile(targetPath, 'utf8');
console.log('Test 3 - User preserved:', content.includes('Custom user content'));
console.log('Test 3 - Old removed:', !content.includes('Old Skill'));
console.log('Test 3 - New added:', content.includes('New Skill'));

// Cleanup
await rm(testDir, { recursive: true, force: true });
```
  </verify>
  <done>
Merge orchestrator implements complete flow: read/create -> split -> generate -> merge -> idempotency check -> safe write -> validate user content.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create embedding module index with unified exports</name>
  <files>src/embedding/index.ts</files>
  <action>
Create `src/embedding/index.ts` to export the complete embedding API:

```typescript
// Section extraction
export { splitContent, detectSectionBoundary, extractUserContent } from './section-extractor.js';

// Section generation
export { generateSkillsSection, generateCommandsSection } from './section-generator.js';

// Template generation
export { generateTemplate, TEMPLATE_HEADER_COMMENT } from './template-generator.js';

// Main merge API
export { mergeEmbeddedContent } from './content-merger.js';

// Re-export types
export type { SectionBoundary, SplitContent, EmbeddedSection } from '../types/embedding.js';
export type { MergeOptions, MergeResult } from './content-merger.js';
```

This provides a clean API surface:
- `mergeEmbeddedContent` - Main entry point for Phase 4 CLI
- `splitContent` - For diagnostic/inspection use
- `generateSkillsSection`, `generateCommandsSection` - For custom composition
- `generateTemplate` - For creating new files
  </action>
  <verify>
`npm run build` succeeds.
Test imports work:
```typescript
import {
  mergeEmbeddedContent,
  splitContent,
  generateSkillsSection,
  generateCommandsSection,
  generateTemplate,
  TEMPLATE_HEADER_COMMENT
} from './src/embedding/index.js';

console.log('All exports available:', typeof mergeEmbeddedContent === 'function');
```
  </verify>
  <done>
Embedding module exports complete API through single index.ts entry point.
  </done>
</task>

</tasks>

<verification>
1. Full merge flow works end-to-end
2. New files created with proper template
3. Existing files: user content preserved, embedded sections replaced
4. Idempotency: no write when content identical
5. User content validation catches any corruption
6. All exports accessible through src/embedding/index.ts
</verification>

<success_criteria>
- `npm run build` passes
- mergeEmbeddedContent creates new file with template when target doesn't exist
- mergeEmbeddedContent preserves user content and replaces embedded sections
- Idempotency check skips write when content identical
- User content validation throws if content corrupted (safety net)
- Horizontal rule separator (`---`) appears between user content and embedded sections
- All embedding functions exported through index.ts
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-embedding/03-03-SUMMARY.md`
</output>
