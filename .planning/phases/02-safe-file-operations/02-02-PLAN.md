---
phase: 02-safe-file-operations
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/file-safety/atomic-writer.ts
  - src/file-safety/markdown-validator.ts
  - src/file-safety/index.ts
autonomous: true

must_haves:
  truths:
    - "File writes use atomic write-to-temp-then-rename pattern"
    - "Temp files created in same directory as target file"
    - "Temp files preserved on failure for debugging"
    - "Written content validated as non-empty markdown"
    - "UTF-8 encoding enforced for all file operations"
    - "Clear error messages on write failure with path and reason"
  artifacts:
    - path: "src/file-safety/atomic-writer.ts"
      provides: "Atomic file write operations"
      exports: ["atomicWrite"]
    - path: "src/file-safety/markdown-validator.ts"
      provides: "Post-write content validation"
      exports: ["validateMarkdownStructure"]
  key_links:
    - from: "src/file-safety/atomic-writer.ts"
      to: "fs/promises"
      via: "writeFile and rename operations"
      pattern: "import.*writeFile.*rename.*from.*fs/promises"
    - from: "src/file-safety/atomic-writer.ts"
      to: "crypto"
      via: "randomBytes for temp filename"
      pattern: "import.*randomBytes.*from.*crypto"
---

<objective>
Implement atomic file write operations that prevent partial writes and data corruption.

Purpose: Atomic writes ensure that file modifications either completely succeed or completely fail - no partial state that corrupts CLAUDE.md files.

Output: Atomic writer using temp-then-rename pattern, plus markdown validator for post-write verification.
</objective>

<execution_context>
@/Users/antonin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/antonin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-safe-file-operations/02-CONTEXT.md
@.planning/phases/02-safe-file-operations/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create atomic writer with temp-then-rename pattern</name>
  <files>src/file-safety/atomic-writer.ts</files>
  <action>
Create atomic-writer.ts with:

1. atomicWrite(targetPath: string, content: string): Promise&lt;void&gt;
   - Generate unique temp filename using crypto.randomBytes(8).toString('hex')
   - Temp file format: .{basename}.tmp.{randomHex} in same directory as target
   - Example: .CLAUDE.md.tmp.a3b2c1d4e5f67890
   - Write content to temp file with { encoding: 'utf8' } (enforces SAFETY-05)
   - Rename temp file to target using fs.promises.rename (atomic on same filesystem)
   - On success: temp file is gone (renamed to target)
   - On failure: DO NOT delete temp file (per CONTEXT.md - keep for debugging)

Error handling:
- ENOSPC (disk full): "Insufficient disk space to write: {targetPath}\nFree up disk space and try again."
- EACCES (permission denied): "Permission denied writing: {targetPath}\nCheck file permissions."
- ENOENT (parent directory missing): "Directory does not exist: {dirname}\nCreate the directory first."
- Other errors: "Write failed: {targetPath}\nReason: {error.message}"

On error, throw Error with descriptive message including targetPath.
Temp file remains for debugging when write or rename fails.

Import from:
- fs/promises: writeFile, rename
- path: dirname, basename, join
- crypto: randomBytes
  </action>
  <verify>
npm run build succeeds.
Test atomic write:
1. Write content to test file using atomicWrite
2. Verify target file exists with correct content
3. Verify no temp files left behind on success
4. Test failure case (e.g., write to read-only directory)
5. Verify temp file remains after failure
  </verify>
  <done>
atomicWrite uses temp-then-rename pattern for atomic file updates.
Temp files in same directory as target (required for atomic rename).
Temp files preserved on failure for debugging.
Error messages include path and specific reason.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create markdown structure validator and update module index</name>
  <files>
src/file-safety/markdown-validator.ts
src/file-safety/index.ts
  </files>
  <action>
Create markdown-validator.ts:

1. ValidationResult interface:
   - valid: boolean
   - errors: string[] (list of validation failures)

2. validateMarkdownStructure(content: string): ValidationResult
   - Check content is not empty/whitespace-only
   - Check content contains at least one markdown heading (^#{1,6}\s+.+$)
   - Return { valid: true, errors: [] } if all checks pass
   - Return { valid: false, errors: [...] } with specific failure reasons

Validation rules (minimal, not overly strict):
- "Content is empty" - if content.trim() is empty
- "Missing markdown headings" - if no # heading found

Note: This is intentionally minimal validation. We're checking for obviously broken output,
not enforcing strict markdown spec. A file with just text and no headings is questionable
but a file that's completely empty is clearly wrong.

Update index.ts:
- Add export for atomicWrite from atomic-writer.ts
- Add export for validateMarkdownStructure and ValidationResult from markdown-validator.ts
  </action>
  <verify>
npm run build succeeds.
Test validation:
1. Valid content with headings - returns valid: true
2. Empty string - returns valid: false with "Content is empty"
3. Content without headings - returns valid: false with "Missing markdown headings"
4. Import from index.ts works for all exports
  </verify>
  <done>
validateMarkdownStructure detects empty content and missing headings.
Module index exports atomic writer and validator functions.
Validation is minimal (catches obvious corruption, not strict markdown linting).
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. npm run build compiles without errors
2. src/file-safety/ contains atomic-writer.ts and markdown-validator.ts
3. atomicWrite successfully writes files using temp-then-rename
4. Temp files remain when operations fail
5. validateMarkdownStructure catches empty content and missing headings
</verification>

<success_criteria>
- Atomic writes prevent partial file corruption
- Temp files in same directory as target (atomic rename requirement)
- Failed writes leave temp file for debugging
- Clear error messages with path and specific reason
- Markdown validation catches obviously broken output
- All functions exported through module index
</success_criteria>

<output>
After completion, create `.planning/phases/02-safe-file-operations/02-02-SUMMARY.md`
</output>
