---
phase: 02-safe-file-operations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/file-safety/hash-generator.ts
  - src/file-safety/backup-manager.ts
  - src/file-safety/retention-policy.ts
  - src/file-safety/index.ts
autonomous: true

must_haves:
  truths:
    - "Backup file created before any write operation"
    - "Backup filename includes timestamp and content hash"
    - "Backup verified readable with matching hash after creation"
    - "Old backups deleted based on retention policy"
    - "Backup creation failure halts operation with clear error"
  artifacts:
    - path: "src/file-safety/hash-generator.ts"
      provides: "SHA-256 content hashing utilities"
      exports: ["generateContentHash", "generateBackupFilename"]
    - path: "src/file-safety/backup-manager.ts"
      provides: "Backup creation and verification"
      exports: ["createBackup", "verifyBackup"]
    - path: "src/file-safety/retention-policy.ts"
      provides: "Time-based backup cleanup"
      exports: ["cleanupOldBackups"]
    - path: "src/file-safety/index.ts"
      provides: "Module exports"
      exports: ["createBackup", "verifyBackup", "cleanupOldBackups", "generateContentHash"]
  key_links:
    - from: "src/file-safety/backup-manager.ts"
      to: "src/file-safety/hash-generator.ts"
      via: "import for hash generation"
      pattern: "import.*from.*hash-generator"
    - from: "src/file-safety/backup-manager.ts"
      to: "fs/promises"
      via: "Node.js file operations"
      pattern: "import.*from.*fs/promises"
---

<objective>
Create backup infrastructure for protecting CLAUDE.md and AGENTS.md files during write operations.

Purpose: Establish foundation for file safety - backups with content verification ensure recoverability if writes fail or produce invalid output.

Output: Hash generator, backup manager, and retention cleanup utilities that enable safe file modifications.
</objective>

<execution_context>
@/Users/antonin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/antonin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-safe-file-operations/02-CONTEXT.md
@.planning/phases/02-safe-file-operations/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create hash generator and backup filename utilities</name>
  <files>src/file-safety/hash-generator.ts</files>
  <action>
Create hash-generator.ts with:

1. generateContentHash(content: string): string
   - Use crypto.createHash('sha256') with UTF-8 encoding
   - Return first 16 characters of hex digest (sufficient for unique identification)
   - Handle empty content edge case (still return valid hash)

2. generateBackupFilename(originalName: string, timestamp: Date, hash: string): string
   - Format: {baseName}_{timestamp}_{hash}.md
   - Timestamp format: ISO 8601 with colons replaced by hyphens (filesystem-safe)
   - Example: CLAUDE_2026-02-03T12-30-45.123Z_a3b2c1d4e5f67890.md
   - Strip .md extension from baseName before adding it back

Use native Node.js crypto module only (no external dependencies).
Export both functions.
  </action>
  <verify>
npm run build succeeds.
Create test file that:
- Generates hash for "test content" (should be deterministic)
- Generates backup filename and verifies format matches pattern
  </verify>
  <done>
generateContentHash returns consistent 16-char hex hash for same input.
generateBackupFilename produces filesystem-safe names with timestamp and hash.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create backup manager with creation and verification</name>
  <files>src/file-safety/backup-manager.ts</files>
  <action>
Create backup-manager.ts with:

1. BackupResult interface:
   - backupPath: string (absolute path to backup file)
   - originalHash: string (hash of original content)
   - verified: boolean (backup verification status)

2. createBackup(targetPath: string, backupDir: string): Promise&lt;BackupResult&gt;
   - Read current file content from targetPath with UTF-8 encoding
   - Generate content hash using hash-generator
   - Generate backup filename with current timestamp and hash
   - Create backup directory with mkdir({ recursive: true })
   - Write backup file with UTF-8 encoding
   - Call verifyBackup to confirm backup is valid
   - Return BackupResult with all details
   - On any failure: throw with clear error including targetPath and reason

3. verifyBackup(backupPath: string, expectedHash: string): Promise&lt;void&gt;
   - Read backup file content
   - Generate hash of backup content
   - Compare with expectedHash
   - Throw if hash mismatch: "Backup verification failed: hash mismatch for {backupPath}"
   - Throw if file unreadable: "Backup verification failed: cannot read {backupPath}"

Use ENOSPC error handling from research (specific message for disk full).
Use EACCES error handling (specific message for permission denied).
Backup directory: .agent-compiler/backups/ relative to project root (pass full path from caller).

Import generateContentHash and generateBackupFilename from hash-generator.
  </action>
  <verify>
npm run build succeeds.
Test with actual file:
1. Create test file with known content
2. Call createBackup
3. Verify backup file exists in backup directory
4. Verify backup filename contains hash and timestamp
5. Verify backup content matches original
  </verify>
  <done>
createBackup creates verified backup with hash-based filename.
verifyBackup confirms backup content matches original.
Errors include file path and specific reason (disk full, permission denied, etc).
  </done>
</task>

<task type="auto">
  <name>Task 3: Create retention policy and module index</name>
  <files>
src/file-safety/retention-policy.ts
src/file-safety/index.ts
  </files>
  <action>
Create retention-policy.ts:

1. CleanupResult interface:
   - deletedCount: number
   - deletedFiles: string[] (filenames only, not paths)
   - keptCount: number

2. cleanupOldBackups(backupDir: string, retentionDays?: number): Promise&lt;CleanupResult&gt;
   - Default retentionDays: 30 (per research recommendation)
   - Read backup directory with fs.promises.readdir
   - For each .md file, check modification time with fs.promises.stat
   - Delete files older than retentionDays using fs.promises.unlink
   - Return CleanupResult with counts and deleted filenames
   - Handle missing directory gracefully (return zeros, don't throw)
   - Warn on individual delete failures but continue processing

Create index.ts:
- Export all from hash-generator.ts
- Export all from backup-manager.ts
- Export all from retention-policy.ts
- Export types: BackupResult, CleanupResult
  </action>
  <verify>
npm run build succeeds.
Test cleanup:
1. Create backup directory with test files of varying ages (use touch with past dates or fs.utimes)
2. Call cleanupOldBackups with short retention (1 day)
3. Verify old files deleted, recent files kept
4. Verify CleanupResult matches actual deletions
  </verify>
  <done>
cleanupOldBackups deletes backups older than retention period.
Module index exports all backup infrastructure functions and types.
Missing backup directory handled gracefully without errors.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. npm run build compiles without errors
2. src/file-safety/ directory contains 4 files (hash-generator, backup-manager, retention-policy, index)
3. All exports available from src/file-safety/index.ts
4. Manual test: create backup of test file, verify backup exists and is readable
</verification>

<success_criteria>
- Backup files created with {name}_{timestamp}_{hash}.md format
- Backup content verified with SHA-256 hash comparison
- Backup creation failure throws with clear error message
- Old backups cleaned up based on configurable retention period
- All functions exported through module index
</success_criteria>

<output>
After completion, create `.planning/phases/02-safe-file-operations/02-01-SUMMARY.md`
</output>
