---
phase: 01-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/parser/skill-parser.ts
  - src/parser/command-parser.ts
  - src/parser/markdown-concat.ts
  - src/parser/index.ts
autonomous: true

must_haves:
  truths:
    - "Tool parses YAML frontmatter from SKILL.md files"
    - "Tool extracts markdown content separate from frontmatter"
    - "Tool concatenates referenced markdown files in document order"
    - "Tool skips non-markdown files during concatenation"
    - "Tool fails fast with clear errors for malformed YAML"
    - "YAML 1.2 parsing avoids edge cases (Norway problem, octal)"
  artifacts:
    - path: "src/parser/skill-parser.ts"
      provides: "SKILL.md parsing with YAML frontmatter"
      exports: ["parseSkillFile"]
    - path: "src/parser/command-parser.ts"
      provides: "Command markdown parsing"
      exports: ["parseCommandFile"]
    - path: "src/parser/markdown-concat.ts"
      provides: "Markdown file concatenation"
      exports: ["extractMarkdownReferences", "concatenateFiles"]
    - path: "src/parser/index.ts"
      provides: "Parser module exports"
      exports: ["parseSkillFile", "parseCommandFile", "extractMarkdownReferences", "concatenateFiles"]
  key_links:
    - from: "src/parser/skill-parser.ts"
      to: "gray-matter"
      via: "matter() call with custom YAML engine"
      pattern: "matter\\("
    - from: "src/parser/skill-parser.ts"
      to: "js-yaml"
      via: "yaml.JSON_SCHEMA for safe parsing"
      pattern: "JSON_SCHEMA"
    - from: "src/parser/markdown-concat.ts"
      to: "fs/promises"
      via: "readFile for loading referenced files"
      pattern: "readFile\\("
---

<objective>
Implement content parsing for SKILL.md files (YAML frontmatter + markdown) and markdown concatenation.

Purpose: Enable the tool to extract metadata and content from skills, then combine multi-file skills into single embeddable content.
Output: Parser functions that return structured skill data with concatenated content.
</objective>

<execution_context>
@/Users/antonin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/antonin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement SKILL.md parser with safe YAML frontmatter extraction</name>
  <files>src/parser/skill-parser.ts</files>
  <action>
    Create src/parser/skill-parser.ts that parses YAML frontmatter using YAML 1.2 safe schema:

    ```typescript
    import matter from 'gray-matter';
    import yaml from 'js-yaml';
    import type { SkillMetadata } from '../types/index.js';

    export interface ParsedSkillContent {
      metadata: SkillMetadata;
      content: string;
      warnings: string[];
    }

    /**
     * Parse a SKILL.md file, extracting YAML frontmatter and markdown content.
     * Uses YAML 1.2 JSON_SCHEMA to avoid edge cases (Norway problem, octal, sexagesimal).
     * Fails fast on malformed YAML with clear error message.
     */
    export function parseSkillFile(filepath: string, fileContent: string): ParsedSkillContent {
      const warnings: string[] = [];

      try {
        const parsed = matter(fileContent, {
          engines: {
            yaml: (str) => yaml.load(str, {
              schema: yaml.JSON_SCHEMA  // YAML 1.2 safe parsing
            }) as Record<string, unknown>
          }
        });

        const metadata = parsed.data as SkillMetadata;

        // Validate required fields - warn if missing, don't fail
        if (!metadata.name) {
          warnings.push(`Warning: ${filepath} missing "name" in frontmatter`);
        }
        if (!metadata.description) {
          warnings.push(`Warning: ${filepath} missing "description" in frontmatter`);
        }

        return {
          metadata: {
            name: metadata.name || '',
            description: metadata.description || '',
            ...metadata
          },
          content: parsed.content,
          warnings
        };
      } catch (error) {
        // Fail fast with clear error for malformed YAML
        const message = error instanceof Error ? error.message : String(error);
        throw new Error(
          `Failed to parse ${filepath}\n` +
          `YAML frontmatter is malformed.\n` +
          `Original error: ${message}`
        );
      }
    }
    ```

    Key points:
    - Use gray-matter with custom YAML engine
    - JSON_SCHEMA prevents implicit type conversions (Norway problem: "no" -> false)
    - Warn on missing name/description but don't fail
    - Fail fast with clear error on malformed YAML
  </action>
  <verify>
    - `npm run build` compiles without errors
    - Test with valid YAML frontmatter
    - Test with "no" as a value (should stay string, not become boolean)
    - Test with malformed YAML (should throw clear error)
  </verify>
  <done>
    Skill parser extracts metadata and content, handles YAML edge cases, fails clearly on malformed input.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement markdown reference extraction and file concatenation</name>
  <files>src/parser/markdown-concat.ts</files>
  <action>
    Create src/parser/markdown-concat.ts that extracts markdown link references and concatenates files:

    ```typescript
    import { readFile } from 'fs/promises';
    import { dirname, join, extname } from 'path';

    /**
     * Extract relative markdown file references from content.
     * Looks for markdown links: [text](file.md)
     * Skips URLs (http/https), anchors (#), and non-.md files.
     * Preserves document order.
     */
    export function extractMarkdownReferences(content: string): string[] {
      // Regex: [text](url) - captures link target
      const linkRegex = /\[([^\[\]]+)\]\(([^)]+)\)/g;
      const references: string[] = [];
      let match;

      while ((match = linkRegex.exec(content)) !== null) {
        const linkTarget = match[2];

        // Only include relative .md file references
        if (!linkTarget.startsWith('http://') &&
            !linkTarget.startsWith('https://') &&
            !linkTarget.startsWith('#') &&
            extname(linkTarget) === '.md') {
          // Avoid duplicates while preserving order
          if (!references.includes(linkTarget)) {
            references.push(linkTarget);
          }
        }
      }

      return references;
    }

    /**
     * Concatenate referenced markdown files with the main content.
     * Files are concatenated in the order they appear in references.
     * Adds separator (---) between files for clarity.
     * Fails with clear error if referenced file doesn't exist.
     */
    export async function concatenateFiles(
      mainPath: string,
      mainContent: string,
      references: string[]
    ): Promise<string> {
      if (references.length === 0) {
        return mainContent;
      }

      const baseDir = dirname(mainPath);
      let concatenated = mainContent;

      for (const ref of references) {
        const refPath = join(baseDir, ref);

        try {
          const refContent = await readFile(refPath, 'utf-8');
          concatenated += '\n\n---\n\n' + refContent;
        } catch (error) {
          // Fail fast with clear error if referenced file doesn't exist
          const nodeError = error as NodeJS.ErrnoException;
          if (nodeError.code === 'ENOENT') {
            throw new Error(
              `Referenced file not found: ${ref}\n` +
              `Referenced in: ${mainPath}\n` +
              `Expected at: ${refPath}`
            );
          }
          throw error;
        }
      }

      return concatenated;
    }
    ```

    Key points:
    - Regex extracts [text](file.md) links, skips URLs and anchors
    - Only .md files processed (PARSE-04: skip non-markdown)
    - Preserves reference order (no Set, use Array with duplicate check)
    - Sequential processing to maintain order
    - Clear error on missing referenced file
  </action>
  <verify>
    - `npm run build` compiles without errors
    - Test extractMarkdownReferences with various link types
    - Test concatenateFiles with existing and missing files
  </verify>
  <done>
    Markdown references extracted in order, files concatenated with separators, missing files error clearly.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement command parser and create parser module index</name>
  <files>src/parser/command-parser.ts, src/parser/index.ts</files>
  <action>
    1. Create src/parser/command-parser.ts (simpler than skills - no YAML frontmatter):

       ```typescript
       import { basename } from 'path';

       export interface ParsedCommandContent {
         name: string;
         content: string;
       }

       /**
        * Parse a command markdown file.
        * Commands are simpler than skills - just markdown content, no frontmatter.
        * Name is derived from filename (without .md extension).
        */
       export function parseCommandFile(filepath: string, fileContent: string): ParsedCommandContent {
         // Derive command name from filename: /path/to/my-command.md -> my-command
         const filename = basename(filepath, '.md');

         return {
           name: filename,
           content: fileContent.trim()
         };
       }
       ```

    2. Create src/parser/index.ts that exports all parser functions:

       ```typescript
       export { parseSkillFile, type ParsedSkillContent } from './skill-parser.js';
       export { parseCommandFile, type ParsedCommandContent } from './command-parser.js';
       export { extractMarkdownReferences, concatenateFiles } from './markdown-concat.js';
       ```
  </action>
  <verify>
    - `npm run build` compiles without errors
    - All exports available: parseSkillFile, parseCommandFile, extractMarkdownReferences, concatenateFiles
  </verify>
  <done>
    Parser module complete with all exports for skills and commands.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run build` - compiles without errors
2. Create integration test:
   - Create test SKILL.md with frontmatter and references
   - Parse with parseSkillFile
   - Extract references
   - Concatenate files
   - Verify final content includes all referenced files in order
3. Test YAML edge cases:
   - "no" value stays string
   - "013" stays string (not octal)
   - Malformed YAML throws clear error
4. Test missing file handling:
   - Reference to non-existent file throws descriptive error
</verification>

<success_criteria>
- parseSkillFile() extracts YAML frontmatter with JSON_SCHEMA (YAML 1.2)
- parseSkillFile() returns markdown content separate from metadata
- parseSkillFile() warns on missing name/description fields
- parseSkillFile() fails fast with clear error on malformed YAML
- extractMarkdownReferences() finds [text](file.md) links, preserves order
- concatenateFiles() combines files with --- separators
- concatenateFiles() fails clearly on missing referenced files
- parseCommandFile() extracts content with name from filename
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
